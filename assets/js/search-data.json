{
  
    
        "post0": {
            "title": "Understanding The Data -- Minecraft Mining",
            "content": "What is the Optimal Method to Mine in Minecraft . To answer this question we must first collect data. To do this I created a minecraft mod that randomly teleports the player, samples a 500x50x500 (X,Y,Z) set of blocks around the player and logs those blocks into a csv. It repeats this a total of 10 times creating 10 samples of 500x50x500 blocks . The mod can be seen here: https://github.com/JPrier/MinecraftBlocksDistribution . Data . Here we will use Pandas to read in the data to be used to visualize distributions. . import pandas as pd import plotly.express as px from IPython.display import HTML . . df = pd.read_csv(&#39;./distributionLogs/3122-data.csv&#39;, error_bad_lines=False) with pd.option_context(&#39;display.max_rows&#39;, 10, &#39;display.max_columns&#39;, None): print(df) . X Y Z Block sample playerX playerY playerZ 0 -5831 0 6935 bedrock 0 -5581.0 50.0 7185.0 1 -5830 0 6935 bedrock 0 -5581.0 50.0 7185.0 2 -5829 0 6935 bedrock 0 -5581.0 50.0 7185.0 3 -5828 0 6935 bedrock 0 -5581.0 50.0 7185.0 4 -5827 0 6935 bedrock 0 -5581.0 50.0 7185.0 ... ... .. ... ... ... ... ... ... 128010505 13966 50 -10793 water 9 13720.0 50.0 -11043.0 128010506 13967 50 -10793 water 9 13720.0 50.0 -11043.0 128010507 13968 50 -10793 water 9 13720.0 50.0 -11043.0 128010508 13969 50 -10793 water 9 13720.0 50.0 -11043.0 128010509 13970 50 -10793 water 9 13720.0 50.0 -11043.0 [128010510 rows x 8 columns] . Visualize Distributions . Here we want to visualize the blocks and their frequency . importantBlocks = [&#39;coal_ore&#39;, &#39;gold_ore&#39;, &#39;iron_ore&#39;, &#39;diamond_ore&#39;, &#39;lapis_ore&#39;, &#39;redstone_ore&#39;, &#39;emerald_ore&#39;] df_blocks = df.loc[df[&#39;Block&#39;].isin(importantBlocks)] # Create distribution plots of block vs Y level # df_blocks.hist(column=&#39;Y&#39;, by=&#39;Block&#39;, figsize=(10, 800), layout=(80,1)) fig = px.histogram(df_blocks, x=&quot;Y&quot;, color=&quot;Block&quot;) HTML(fig.to_html()) # fig.show() # Create HeatMaps of blocks with X-Z, X-Y, Y-Z, and 3d X-Y-Z # TODO: fix X and Z values s.t. the samples are shown together in heatmap fig = px.density_heatmap(df_blocks, x=&quot;X&quot;, y=&quot;Y&quot;) # fig.show() # plt.plot() . What is the best method . Now that we have the data and have seen the distributions of blocks through our samples lets see how different methods of mining do. . Calculating the best method . We will compare each of the methods based on these data points: . Number of blocks mined | Number of desired blocks mined | . TODO (What to figure out) . Should methods be done on every level and each be compared? | If a player sees diamonds they will mine all of them, need to grab all visible ore | . # Starting from the player calculate each of the methods at different starting levels. save each into a dataframe def strip_mining(): # +250X @ Y, Y+1, -250X @ Y, Y+1 -- repeat for +2Z, -2Z # # Get range of coords. Should be an O(1) process by just selecting a set of blocks from coords given the player&#39;s starting location # # Create tuples [X, Y, Z] and get the blocks at those coords. Need to also grab all &quot;visible&quot; blocks (need a method to &quot;mine&quot;) # # # Strip 1 xRange = [0, 250], yRange = [0, 1], zRange = [0] # repeat each 3 Z s.t. there are 2 blocks in between strips # Need zRange = [0, 3, 6, 9, ..., Z&lt;=250] pass # Calculate the frequency of blocks seen with each method at different levels # Show the &quot;Scores&quot; .",
            "url": "https://jprier.github.io/josh-blog/minecraft/understanding%20the%20data/data%20science/2021/02/01/MinecraftBlocks.html",
            "relUrl": "/minecraft/understanding%20the%20data/data%20science/2021/02/01/MinecraftBlocks.html",
            "date": " • Feb 1, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Understanding The Data -- Kovaaks Aim Trainer",
            "content": "Kovaaks . Kovaaks is a &quot;game&quot; that allows to directly practice mouse control in 3d fps games. There are hundreds of different mini-games to practice with, each having a different focus. . This guide is best for getting perspective or understanding how and why to use Kovaaks . File Names . Kovaaks has a great feature in which it saves every mini-game&#39;s stats to a csv. The format of the csv&#39;s names is as follows . &lt;scenario name&gt; - &lt;Challenge or Freeplay&gt; - YYYY.MM.DD-HH.MM.SS Stats.csv . Example: . Tile Frenzy - Challenge - 2020.12.14-08.46.00 Stats.csv . Some of the scenario names also have dashes so just checking against the first dash will not work . Tile Frenzy - Strafing - 03 - Challenge - 2020.12.14-08.34.31 Stats.csv . The Data . Each file has 4 parts: . List of all Kills | Weapon, shots, hits, damage done, damage possible | Overall Stats and info | Info about settings (input lag, fps, sens, FOV, etc) | . import pandas as pd import matplotlib.pyplot as plt from urllib.request import urlopen from io import StringIO from IPython.display import display import ipywidgets as widgets from ipywidgets import interact . . Each part of the data has different formats and headers. Here are the Headers/keys in python . keys_kills=[&quot;Date&quot;,&quot;Kill #&quot;,&quot;Timestamp&quot;,&quot;Bot&quot;,&quot;Weapon&quot;,&quot;TTK&quot;,&quot;Shots&quot;,&quot;Hits&quot;,&quot;Accuracy&quot;,&quot;Damage Done&quot;,&quot;Damage Possible&quot;,&quot;Efficiency&quot;,&quot;Cheated&quot;] keys_weapon=[&quot;Date&quot;,&quot;Weapon&quot;,&quot;Shots&quot;,&quot;Hits&quot;,&quot;Damage Done&quot;,&quot;Damage Possible&quot;] keys_info=[&quot;Date&quot;,&quot;Kills&quot;,&quot;Deaths&quot;,&quot;Fight Time&quot;,&quot;Avg TTK&quot;,&quot;Damage Done&quot;,&quot;Damage Taken&quot;,&quot;Midairs&quot;,&quot;Midaired&quot;,&quot;Directs&quot;,&quot;Directed&quot;,&quot;Distance Traveled&quot;,&quot;Score&quot;,&quot;Scenario&quot;,&quot;Hash&quot;,&quot;Game Version&quot;,&quot;Challenge Start&quot;,&quot;Input Lag&quot;,&quot;Max FPS (config)&quot;,&quot;Sens Scale&quot;,&quot;Horiz Sens&quot;,&quot;Vert Sens&quot;,&quot;FOV&quot;,&quot;Hide Gun&quot;,&quot;Crosshair&quot;,&quot;Crosshair Scale&quot;,&quot;Crosshair Color&quot;,&quot;Resolution&quot;,&quot;Avg FPS&quot;,&quot;Resolution Scale&quot;] keys_info_no_colon=[&quot;Resolution&quot;,&quot;Avg FPS&quot;,&quot;Resolution Scale&quot;] . . #HELPERS def split_format_file(section, output, date): split_section = section.split(&#39; n&#39;) # if output == &quot;&quot;: # output = split_section[0] # TODO: Add date to each line for i in range(len(split_section[1:])): if split_section[i+1][-1] == &#39;,&#39;: split_section[i+1] = split_section[i+1][:-1] split_section[i+1] = date + &quot;,&quot; + split_section[i+1] section = &#39; n&#39;.join(split_section[1:]) output = output + &#39; n&#39; + section return output def format_info(info, output, date): info_lines = info.split(&#39; n&#39;) data = [] for key in keys_info: if key == &quot;Date&quot;: found_key = True data.append(date) else: found_key = False for line in info_lines: if any(key in line for key in keys_info_no_colon): split_line = line.split(&#39;,&#39;) if len(split_line) &gt; 1: if split_line[0] == key: found_key = True data.append(split_line[1]) else: split_line = line.split(&#39;:&#39;, 1) if len(split_line) &gt; 1: if split_line[0] == key: found_key = True data.append(split_line[1][1:]) if not found_key: data.append(&#39;&#39;) output = output + &#39; n&#39; + &#39;,&#39;.join(data) return output . . # Current online directory for my stats stat_dir = &quot;https://jprier.github.io/stats/&quot; stat_filenames_url = &quot;https://jprier.github.io/stats/filenames.txt&quot; stat_filenames = urlopen(stat_filenames_url).read().decode(&#39;utf-8&#39;).split(&#39; n&#39;) kills = &#39;,&#39;.join(keys_kills) weapon = &#39;,&#39;.join(keys_weapon) info = &#39;,&#39;.join(keys_info) for filename in stat_filenames: # TODO: parse filename for challenge name and date try: filename = filename.replace(&#39; &#39;, &#39;%20&#39;) file = urlopen(stat_dir + filename).read().decode(&#39;utf-8&#39;).split(&#39; n n&#39;) if len(file) &gt; 1: date = filename.split(&#39;%20&#39;)[-2] # TODO: Add challenge name and date to each as columns kills = split_format_file(file[0], kills, date) # file[1] --&gt; df_weapon weapon = split_format_file(file[1], weapon, date) # file[2,3] --&gt; df_info info = format_info(file[2]+&quot; n&quot;+file[3], info, date) except Exception as err: print(err) df_kills = pd.read_csv(StringIO(kills), sep=&quot;,&quot;) df_weapons = pd.read_csv(StringIO(weapon), sep=&quot;,&quot;) df_info = pd.read_csv(StringIO(info), sep=&quot;,&quot;) df_kills[&quot;Date&quot;] = pd.to_datetime(df_kills.Date, format=&#39;%Y.%m.%d-%H.%M.%S&#39;)#df_kills[&quot;Date&quot;].dt.strftime(&quot;%Y.%d.%m-%H.%M.%S&quot;) df_weapons[&quot;Date&quot;] = pd.to_datetime(df_weapons.Date, format=&#39;%Y.%m.%d-%H.%M.%S&#39;)#df_weapons[&quot;Date&quot;].dt.strftime(&quot;%Y.%d.%m-%H.%M.%S&quot;) df_info[&quot;Date&quot;] = pd.to_datetime(df_info.Date, format=&#39;%Y.%m.%d-%H.%M.%S&#39;)#df_info[&quot;Date&quot;].dt.strftime(&quot;%Y.%d.%m-%H.%M.%S&quot;) with pd.option_context(&#39;display.max_rows&#39;, 10, &#39;display.max_columns&#39;, None): display(df_kills) display(df_weapons) display(df_info) . . HTTP Error 404: Not Found . Date Kill # Timestamp Bot Weapon TTK Shots Hits Accuracy Damage Done Damage Possible Efficiency Cheated . 0 2020-10-25 14:21:19 | 1 | 14:19:43.846 | target | pistol | 0s | 1 | 1 | 1.0 | 100.0 | 400 | 0.250 | False | . 1 2020-10-25 14:21:19 | 2 | 14:19:45.497 | target | pistol | 0.307s | 2 | 1 | 0.5 | 100.0 | 800 | 0.125 | False | . 2 2020-10-25 14:21:19 | 3 | 14:19:46.148 | target | pistol | 0s | 1 | 1 | 1.0 | 100.0 | 400 | 0.250 | False | . 3 2020-10-25 14:21:19 | 4 | 14:19:46.784 | target | pistol | 0s | 1 | 1 | 1.0 | 100.0 | 400 | 0.250 | False | . 4 2020-10-25 14:21:19 | 5 | 14:19:47.384 | target | pistol | 0s | 1 | 1 | 1.0 | 100.0 | 400 | 0.250 | False | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 18452 2020-11-15 16:47:49 | 87 | 16:47:47.289 | Shinji small Bot | pistol | 0s | 1 | 1 | 1.0 | 2000.0 | 2000 | 1.000 | False | . 18453 2020-11-15 16:47:49 | 88 | 16:47:47.834 | Shinji Bot | pistol | 0s | 1 | 1 | 1.0 | 2000.0 | 2000 | 1.000 | False | . 18454 2020-11-15 16:47:49 | 89 | 16:47:48.056 | Shinji Bot | pistol | 0s | 1 | 1 | 1.0 | 2000.0 | 2000 | 1.000 | False | . 18455 2020-11-15 16:47:49 | 90 | 16:47:48.635 | Shinji Bot | pistol | 0s | 1 | 1 | 1.0 | 2000.0 | 2000 | 1.000 | False | . 18456 2020-11-15 16:47:49 | 91 | 16:47:49.203 | Shinji Bot | pistol | 0s | 1 | 1 | 1.0 | 2000.0 | 2000 | 1.000 | False | . 18457 rows × 13 columns . Date Weapon Shots Hits Damage Done Damage Possible . 0 2020-10-25 14:21:19 | pistol | 89 | 81 | 8100.0 | 35600.0 | . 1 2020-10-25 14:22:25 | pistol | 88 | 84 | 8400.0 | 35200.0 | . 2 2020-10-25 14:23:38 | pistol | 89 | 83 | 8300.0 | 35600.0 | . 3 2020-10-25 14:24:44 | pistol | 87 | 81 | 8100.0 | 34800.0 | . 4 2020-10-25 14:26:01 | pistol | 82 | 76 | 7600.0 | 32800.0 | . ... ... | ... | ... | ... | ... | ... | . 508 2020-10-28 19:59:06 | LG | 1289 | 536 | 3216.0 | 7734.0 | . 509 2020-10-28 20:00:09 | LG | 1288 | 579 | 3474.0 | 7728.0 | . 510 2020-10-28 20:01:14 | LG | 1285 | 559 | 3354.0 | 7710.0 | . 511 2020-12-20 12:23:37 | LG | 1281 | 618 | 3708.0 | 7686.0 | . 512 2020-12-20 12:24:55 | LG | 1289 | 622 | 3732.0 | 7734.0 | . 513 rows × 6 columns . Date Kills Deaths Fight Time Avg TTK Damage Done Damage Taken Midairs Midaired Directs Directed Distance Traveled Score Scenario Hash Game Version Challenge Start Input Lag Max FPS (config) Sens Scale Horiz Sens Vert Sens FOV Hide Gun Crosshair Crosshair Scale Crosshair Color Resolution Avg FPS Resolution Scale . 0 2020-10-25 14:21:19 | 81 | 0 | 2.321 | 0.741 | 8100.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 73.719101 | 1wall 1target | b49d715d44114c48760acebae4e1f381 | 2.0.2.0 | NaN | 0 | 300.0 | Quake/Source | 1.5 | 1.5 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 1 2020-10-25 14:22:25 | 84 | 0 | 1.907 | 0.714 | 8400.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 80.181816 | 1wall 1target | b49d715d44114c48760acebae4e1f381 | 2.0.2.0 | NaN | 0 | 300.0 | Quake/Source | 1.5 | 1.5 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 2 2020-10-25 14:23:38 | 83 | 0 | 2.707 | 0.723 | 8300.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 77.404495 | 1wall 1target | b49d715d44114c48760acebae4e1f381 | 2.0.2.0 | NaN | 0 | 300.0 | Quake/Source | 1.5 | 1.5 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 3 2020-10-25 14:24:44 | 81 | 0 | 1.970 | 0.741 | 8100.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 75.413795 | 1wall 1target | b49d715d44114c48760acebae4e1f381 | 2.0.2.0 | NaN | 0 | 300.0 | Quake/Source | 1.5 | 1.5 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 4 2020-10-25 14:26:01 | 76 | 0 | 2.316 | 0.789 | 7600.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 70.439026 | 1wall 1target | b49d715d44114c48760acebae4e1f381 | 2.0.2.0 | NaN | 0 | 300.0 | Quake/Source | 1.2 | 1.2 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 444 2020-10-28 19:59:06 | 0 | 0 | 0.000 | 0.000 | 3216.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 9648.000000 | Vertical Long Strafes | 10dda1a0add87cec31674896c8ae81b4 | 2.0.2.0 | NaN | 0 | 300.0 | Overwatch | 4.0 | 4.0 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 445 2020-10-28 20:00:09 | 0 | 0 | 0.000 | 0.000 | 3474.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 10422.000000 | Vertical Long Strafes | 10dda1a0add87cec31674896c8ae81b4 | 2.0.2.0 | NaN | 0 | 300.0 | Overwatch | 4.0 | 4.0 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 446 2020-10-28 20:01:14 | 0 | 0 | 0.000 | 0.000 | 3354.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 10062.000000 | Vertical Long Strafes | 10dda1a0add87cec31674896c8ae81b4 | 2.0.2.0 | NaN | 0 | 300.0 | Overwatch | 4.0 | 4.0 | 100.0 | False | plus.png | 1.0 | FFFF00 | NaN | NaN | NaN | . 447 2020-12-20 12:23:37 | 0 | 0 | 0.000 | 0.000 | 3708.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 11124.000000 | Vertical Long Strafes | 10dda1a0add87cec31674896c8ae81b4 | 2.0.3.1 | 12:22:37.259 | 0 | 300.0 | Quake/Source | 0.9 | 0.9 | 100.0 | False | plus.png | 1.0 | FFFF00 | 2560x1080 | 299.712189 | 100.0 | . 448 2020-12-20 12:24:55 | 0 | 0 | 0.000 | 0.000 | 3732.0 | 0.0 | 0 | 0 | 0 | 0 | 0.0 | 11196.000000 | Vertical Long Strafes | 10dda1a0add87cec31674896c8ae81b4 | 2.0.3.1 | 12:23:55.624 | 0 | 300.0 | Quake/Source | 0.9 | 0.9 | 100.0 | False | plus.png | 1.0 | FFFF00 | 2560x1080 | 299.442932 | 100.0 | . 449 rows × 30 columns . Visualizing the Data . df_info.loc[df_info[&#39;Scenario&#39;] == &#39;Tile Frenzy&#39;].plot(x=&quot;Date&quot;, y=&quot;Kills&quot;, kind=&#39;scatter&#39;) plt.xticks(rotation=70) plt.show() . scenarios = df_info[&#39;Scenario&#39;].unique().tolist() widgets.Dropdown( options=scenarios, value=&#39;2&#39;, description=&#39;Scenario:&#39;, disabled=False, ) . StopIteration Traceback (most recent call last) c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget_selection.py in findvalue(array, value, compare) 136 try: --&gt; 137 return next(x for x in array if compare(x, value)) 138 except StopIteration: StopIteration: During handling of the above exception, another exception occurred: ValueError Traceback (most recent call last) c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget_selection.py in _validate_value(self, proposal) 240 try: --&gt; 241 return findvalue(self._options_values, value, self.equals) if value is not None else None 242 except ValueError: c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget_selection.py in findvalue(array, value, compare) 138 except StopIteration: --&gt; 139 raise ValueError(&#39;%r not in array&#39;%value) 140 ValueError: &#39;2&#39; not in array During handling of the above exception, another exception occurred: TraitError Traceback (most recent call last) &lt;ipython-input-7-ac85af234663&gt; in &lt;module&gt; 4 value=&#39;2&#39;, 5 description=&#39;Scenario:&#39;, -&gt; 6 disabled=False, 7 ) c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget_selection.py in __init__(self, *args, **kwargs) 188 kwargs[&#39;label&#39;], kwargs[&#39;value&#39;] = options[0] if nonempty else (None, None) 189 --&gt; 190 super(_Selection, self).__init__(*args, **kwargs) 191 self._initializing_traits_ = False 192 c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget.py in __init__(self, **kwargs) 410 &#34;&#34;&#34;Public constructor&#34;&#34;&#34; 411 self._model_id = kwargs.pop(&#39;model_id&#39;, None) --&gt; 412 super(Widget, self).__init__(**kwargs) 413 414 Widget._call_widget_constructed(self) c: users jkpri appdata local programs python python36 lib site-packages traitlets traitlets.py in __init__(self, *args, **kwargs) 998 else: 999 # passthrough args that don&#39;t set traits to super -&gt; 1000 super_kwargs[key] = value 1001 try: 1002 super(HasTraits, self).__init__(*super_args, **super_kwargs) c: users jkpri appdata local programs python python36 lib contextlib.py in __exit__(self, type, value, traceback) 86 if type is None: 87 try: &gt; 88 next(self.gen) 89 except StopIteration: 90 return False c: users jkpri appdata local programs python python36 lib site-packages traitlets traitlets.py in hold_trait_notifications(self) 1120 self._trait_values.pop(name) 1121 cache = {} -&gt; 1122 raise e 1123 finally: 1124 self._cross_validation_lock = False c: users jkpri appdata local programs python python36 lib site-packages traitlets traitlets.py in hold_trait_notifications(self) 1106 for name in list(cache.keys()): 1107 trait = getattr(self.__class__, name) -&gt; 1108 value = trait._cross_validate(self, getattr(self, name)) 1109 self.set_trait(name, value) 1110 except TraitError as e: c: users jkpri appdata local programs python python36 lib site-packages traitlets traitlets.py in _cross_validate(self, obj, value) 597 if self.name in obj._trait_validators: 598 proposal = Bunch({&#39;trait&#39;: self, &#39;value&#39;: value, &#39;owner&#39;: obj}) --&gt; 599 value = obj._trait_validators[self.name](obj, proposal) 600 elif hasattr(obj, &#39;_%s_validate&#39; % self.name): 601 meth_name = &#39;_%s_validate&#39; % self.name c: users jkpri appdata local programs python python36 lib site-packages traitlets traitlets.py in __call__(self, *args, **kwargs) 905 &#34;&#34;&#34;Pass `*args` and `**kwargs` to the handler&#39;s function if it exists.&#34;&#34;&#34; 906 if hasattr(self, &#39;func&#39;): --&gt; 907 return self.func(*args, **kwargs) 908 else: 909 return self._init_call(*args, **kwargs) c: users jkpri appdata local programs python python36 lib site-packages ipywidgets widgets widget_selection.py in _validate_value(self, proposal) 241 return findvalue(self._options_values, value, self.equals) if value is not None else None 242 except ValueError: --&gt; 243 raise TraitError(&#39;Invalid selection: value not found&#39;) 244 245 @observe(&#39;value&#39;) TraitError: Invalid selection: value not found . xSize, ySize = len(scenarios)//2, 2 print(len(scenarios)) plt.rcParams.update({&#39;font.size&#39;: 30}) plt.figure(figsize=(80,500)) for i in range(len(scenarios)): plt.xticks(rotation=70) ax = plt.subplot(xSize, ySize, i+1) df_info.loc[df_info[&#39;Scenario&#39;] == scenarios[i]].plot(ax=ax, x=&quot;Date&quot;, y=&quot;Score&quot;, title=scenarios[i], kind=&#39;scatter&#39;) plt.show() .",
            "url": "https://jprier.github.io/josh-blog/kovaaks/understanding%20the%20data/data%20science/2021/02/01/KovaaksData.html",
            "relUrl": "/kovaaks/understanding%20the%20data/data%20science/2021/02/01/KovaaksData.html",
            "date": " • Feb 1, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Notes From NNFS",
            "content": "Wanting to relearn the ML basics from my university degree I started going through the course Neural Networks From Scratch. . This post contains my notes and learnings from the course. . The Basics of a Layer . A layer of a neural network contains 1 or more neurons, these neurons will take a vector (or matrix with batches) as input and have a vector of weights to multiply by each of the inputs and a bias to add to the input*weights. . input = [1, 2] weights = [1,2] bias = 1 # output of a single neuron output = inputs*weights + bias . This is easily scaled up to multiple neurons with matrices . import numpy as np inputs = [1.0, 2.0, 3.0, 2.5] weights = [[0.2, 0.8, -0.5, 1], [0.5, -0.91, 0.26, -0.5], [-0.26, -0.27, 0.17, 0.87]] biases = [2.0, 3.0, 0.5] layer_outputs = np.dot(weights, inputs) + biases . Tip: numpy shape has an out to in order s.t. in shape(x,y) x is the size of the outmost dimension and y is the size of the most inner dimension . Each layer is essentially the dot product the weights and the previous layer’s output (input data for the first layer) . Batches . In the previous examples we take a vector as an input input = [1,2]. This vector is a single object in our dataset, this can be an image of a dog, the values a house sold, (x,y) values of a point, or anything else. Each value is a feature of the object, a feature describes some aspect of the object. In the case of points on a 2d graph the features for the objects would be the x and y coordinates of each point so our input in this case would be [x, y]. . We do not want to pass a single object as input for each pass of the neural network, this would be slow and would take forever for large datasets. Instead of passing single objects we can pass multiple objects at once in what is called a batch. . A batch will contain 2 or more vectors, typically we have batch sizes of 16-64 with 32 being common. Too small of a batch size will cause the neural network to underfit, this is due to the model not getting enough information in each pass causing it to make too large of a change to the parameters on each pass. Too large of a batch size will cause the neural network to overfit, this is due to it fitting to too much of the sample data at once which will cause the test accuracy to be much lower. . Activation Functions . The Basics . The activation function is a tool to adjust how and when a neuron of the network should activate. A network will typically use a different activation function between the output and hidden layers. . We use the activation function with the calculation of the weights, inputs, and bias per neuron . output = Activaiton(weights*input + bias) . Step Function . A simple activation function is the step function . x = weights*inputs + bias if x &gt; 0 y = 1 else y = 0 . The step function is a binary on or off for a neuron, 1 or 0 depending on the value of the calculation . Linear Activation Function . Sigmoid Function . ReLU .",
            "url": "https://jprier.github.io/josh-blog/studying/2020/12/12/NNFS-Notes.html",
            "relUrl": "/studying/2020/12/12/NNFS-Notes.html",
            "date": " • Dec 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "A Software Development Engineer that wants to learn as much as possible .",
          "url": "https://jprier.github.io/josh-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jprier.github.io/josh-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}