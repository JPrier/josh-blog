{
  
    
        "post0": {
            "title": "Understanding The Data -- Kovaaks Aim Trainer",
            "content": "Kovaaks . Kovaaks is a &quot;game&quot; that allows to directly practice mouse control in 3d fps games. There are hundreds of different mini-games to practice with, each having a different focus. . This guide is best for getting perspective or understanding how and why to use Kovaaks . File Names . Kovaaks has a great feature in which it saves every mini-game&#39;s stats to a csv. The format of the csv&#39;s names is as follows . &lt;scenario name&gt; - &lt;Challenge or Freeplay&gt; - YYYY.MM.DD-HH.MM.SS Stats.csv . Example: . Tile Frenzy - Challenge - 2020.12.14-08.46.00 Stats.csv . Some of the scenario names also have dashes so just checking against the first dash will not work . Tile Frenzy - Strafing - 03 - Challenge - 2020.12.14-08.34.31 Stats.csv . The Data . Each file has 4 parts: . List of all Kills | Weapon, shots, hits, damage done, damage possible | Overall Stats and info | Info about settings (input lag, fps, sens, FOV, etc) | . import pandas as pd from urllib.request import urlopen from io import StringIO . . Each part of the data has different formats and headers. Here are the Headers/keys in python . keys_kills=[&quot;Kill #&quot;,&quot;Timestamp&quot;,&quot;Bot&quot;,&quot;Weapon&quot;,&quot;TTK&quot;,&quot;Shots&quot;,&quot;Hits&quot;,&quot;Accuracy&quot;,&quot;Damage Done&quot;,&quot;Damage Possible&quot;,&quot;Efficiency&quot;,&quot;Cheated&quot;] keys_weapon=[&quot;Weapon&quot;,&quot;Shots&quot;,&quot;Hits&quot;,&quot;Damage Done&quot;,&quot;Damage Possible&quot;] keys_info=[] keys_settings=[] . . # Current online directory for my stats stat_dir = &quot;https://jprier.github.io/stats/&quot; stat_filenames_url = &quot;https://jprier.github.io/stats/filenames.txt&quot; stat_filenames = urlopen(stat_filenames_url).read().decode(&#39;utf-8&#39;).split(&#39; n&#39;) kills = &quot;&quot; weapon = &quot;&quot; info = &quot;&quot; for filename in stat_filenames: # TODO: parse filename for challenge name and date try: filename = filename.replace(&#39; &#39;, &#39;%20&#39;) file = urlopen(stat_dir + filename).read().decode(&#39;utf-8&#39;).split(&#39; n n&#39;) # TODO: Add challenge name and date to each as columns if kills == &quot;&quot;: kills = file[0].split(&#39; n&#39;)[0] file[0] = &#39; n&#39;.join(file[0].split(&#39; n&#39;)[1:]) kills = kills + &#39; n&#39; + file[0] # file[1] --&gt; df_weapon # file[2,3] --&gt; df_info except Exception as err: print(err) df_kills = pd.read_csv(StringIO(kills), sep=&quot;,&quot;) with pd.option_context(&#39;display.max_rows&#39;, 10, &#39;display.max_columns&#39;, None): display(df_kills) . . HTTP Error 403: Forbidden . Kill # Timestamp Bot Weapon TTK Shots Hits Accuracy Damage Done Damage Possible Efficiency Cheated . 0 1 | 14:19:43.846 | target | pistol | 0s | 1.0 | 1.0 | 1.0 | 100.0 | 400.0 | 0.250 | False | . 1 2 | 14:19:45.497 | target | pistol | 0.307s | 2.0 | 1.0 | 0.5 | 100.0 | 800.0 | 0.125 | False | . 2 3 | 14:19:46.148 | target | pistol | 0s | 1.0 | 1.0 | 1.0 | 100.0 | 400.0 | 0.250 | False | . 3 4 | 14:19:46.784 | target | pistol | 0s | 1.0 | 1.0 | 1.0 | 100.0 | 400.0 | 0.250 | False | . 4 5 | 14:19:47.384 | target | pistol | 0s | 1.0 | 1.0 | 1.0 | 100.0 | 400.0 | 0.250 | False | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 16781 87 | 16:47:47.289 | Shinji small Bot | pistol | 0s | 1.0 | 1.0 | 1.0 | 2000.0 | 2000.0 | 1.000 | False | . 16782 88 | 16:47:47.834 | Shinji Bot | pistol | 0s | 1.0 | 1.0 | 1.0 | 2000.0 | 2000.0 | 1.000 | False | . 16783 89 | 16:47:48.056 | Shinji Bot | pistol | 0s | 1.0 | 1.0 | 1.0 | 2000.0 | 2000.0 | 1.000 | False | . 16784 90 | 16:47:48.635 | Shinji Bot | pistol | 0s | 1.0 | 1.0 | 1.0 | 2000.0 | 2000.0 | 1.000 | False | . 16785 91 | 16:47:49.203 | Shinji Bot | pistol | 0s | 1.0 | 1.0 | 1.0 | 2000.0 | 2000.0 | 1.000 | False | . 16786 rows × 12 columns .",
            "url": "https://jprier.github.io/josh-blog/kovaaks/understanding%20the%20data/data%20science/2020/12/15/KovaaksData.html",
            "relUrl": "/kovaaks/understanding%20the%20data/data%20science/2020/12/15/KovaaksData.html",
            "date": " • Dec 15, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "Notes From NNFS",
            "content": "Wanting to relearn the ML basics from my university degree I started going through the course Neural Networks From Scratch. . This post contains my notes and learnings from the course. . The Basics of a Layer . A layer of a neural network contains 1 or more neurons, these neurons will take a vector (or matrix with batches) as input and have a vector of weights to multiply by each of the inputs and a bias to add to the input*weights. . input = [1, 2] weights = [1,2] bias = 1 # output of a single neuron output = inputs*weights + bias . This is easily scaled up to multiple neurons with matrices . import numpy as np inputs = [1.0, 2.0, 3.0, 2.5] weights = [[0.2, 0.8, -0.5, 1], [0.5, -0.91, 0.26, -0.5], [-0.26, -0.27, 0.17, 0.87]] biases = [2.0, 3.0, 0.5] layer_outputs = np.dot(weights, inputs) + biases . Tip: numpy shape has an out to in order s.t. in shape(x,y) x is the size of the outmost dimension and y is the size of the most inner dimension . Each layer is essentially the dot product the weights and the previous layer’s output (input data for the first layer) . Batches . In the previous examples we take a vector as an input input = [1,2]. This vector is a single object in our dataset, this can be an image of a dog, the values a house sold, (x,y) values of a point, or anything else. Each value is a feature of the object, a feature describes some aspect of the object. In the case of points on a 2d graph the features for the objects would be the x and y coordinates of each point so our input in this case would be [x, y]. . We do not want to pass a single object as input for each pass of the neural network, this would be slow and would take forever for large datasets. Instead of passing single objects we can pass multiple objects at once in what is called a batch. . A batch will contain 2 or more vectors, typically we have batch sizes of 16-64 with 32 being common. Too small of a batch size will cause the neural network to underfit, this is due to the model not getting enough information in each pass causing it to make too large of a change to the parameters on each pass. Too large of a batch size will cause the neural network to overfit, this is due to it fitting to too much of the sample data at once which will cause the test accuracy to be much lower. . Activation Functions . The Basics . The activation function is a tool to adjust how and when a neuron of the network should activate. A network will typically use a different activation function between the output and hidden layers. . We use the activation function with the calculation of the weights, inputs, and bias per neuron . output = Activaiton(weights*input + bias) . Step Function . A simple activation function is the step function . x = weights*inputs + bias if x &gt; 0 y = 1 else y = 0 . The step function is a binary on or off for a neuron, 1 or 0 depending on the value of the calculation . Linear Activation Function . Sigmoid Function . ReLU .",
            "url": "https://jprier.github.io/josh-blog/studying/2020/12/12/NNFS-Notes.html",
            "relUrl": "/studying/2020/12/12/NNFS-Notes.html",
            "date": " • Dec 12, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "A Software Development Engineer that wants to learn as much as possible .",
          "url": "https://jprier.github.io/josh-blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jprier.github.io/josh-blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}